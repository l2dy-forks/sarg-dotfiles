#+OPTIONS: num:nil
#+SETUPFILE: ~/devel/ext/org-html-themes/org/theme-readtheorg-local.setup
#+PROPERTY: header-args:scheme :tangle no :exports none
#+begin_src elisp :exports none
;; -*- lexical-binding: t; -*-
#+end_src
* guix
To define guix dependencies add a source code block with =:noweb-ref guix-pkg= as header arguments. It'll be then tangled to =~/.dotfiles/guix/emacs-packages.scm= and merged with the main =home-environment=.

#+begin_src scheme :noweb yes :tangle ~/.dotfiles/guix/emacs-home.scm
(use-modules
 (gnu packages)
 (gnu home))
(home-environment
 (services (list
            <<guix-srv>>
            ))
 (packages
  (map (compose list specification->package+output)
       '("emacs-next"
         "emacs-emacsql"
         "emacs-pdf-tools"
         "emacs-telega"
         "emacs-telega-contrib"
         "emacs-vterm"
         "avfs"
         "emacs-guix"
         <<guix-pkg>>
         ))))
#+end_src

#+begin_src elisp
(after! guix
  (setq guix-repl-use-server nil))
#+end_src
* doom
** init.el
#+begin_src elisp :tangle init.el
(setq doom-leader-key "<f13>"
      doom-leader-alt-key "<f13>")
(doom!
 :completion  company vertico ;(ivy +fuzzy +prescient +childframe)
 :ui          nav-flash (modeline +light) ophints (popup +all +defaults) ligatures hydra
 vc-gutter window-select treemacs
 :editor      (evil +everywhere) fold lispy snippets (format +onsave) multiple-cursors word-wrap
 :emacs       dired electric vc ibuffer undo
 :term        eshell vterm
 :tools       editorconfig (eval +overlay) (lookup +docsets) (magit) pdf (pass +auth) direnv make tree-sitter lsp
 :checkers    syntax
 :lang        clojure data emacs-lisp
 (org +contacts +dragndrop +pandoc +present +hugo +roam2) beancount
 rest sh plantuml (python +pyenv +lsp) (web +html) yaml json
 :app         calendar telega (rss +org) torrent exwm irc
 :email       (mu4e +gmail)
 :config      (default +bindings +smartparens) literate)
#+end_src
* exwm
EXWM config is too big, so it was extracted to a separate [[../.doom.d/modules/app/exwm][doom app]].

#+begin_src scheme :noweb-ref guix-pkg
"emacs-exwm"
#+end_src

* desktop
#+begin_src scheme :noweb-ref guix-pkg
"emacs-desktop-environment"
#+end_src
#+begin_src elisp :tangle packages.el
(package! desktop-environment :built-in t)
#+end_src
#+begin_src elisp
(use-package! desktop-environment
  :after exwm
  :custom
  (desktop-environment-volume-get-command "pactl get-sink-volume @DEFAULT_SINK@")
  (desktop-environment-volume-set-command "pactl set-sink-volume @DEFAULT_SINK@ %s")
  (desktop-environment-volume-toggle-command "pactl set-sink-mute @DEFAULT_SINK@ toggle")
  (desktop-environment-volume-toggle-microphone-command "pactl set-source-mute @DEFAULT_SOURCE@ toggle")
  (desktop-environment-volume-small-decrement "-1%")
  (desktop-environment-volume-small-increment "+1%")
  (desktop-environment-volume-normal-decrement "-5%")
  (desktop-environment-volume-normal-increment "+5%")
  (desktop-environment-screenlock-command "lock.sh")
  (desktop-environment-screenshot-command "flameshot gui")
  (desktop-environment-screenshot-directory (expand-file-name "~/Downloads"))

  :config
  ; dunno, but doom resets the fontspec. Let me fix it here
  (set-fontset-font t 'emoji "Noto Color Emoji") ; ðŸ’ª

  (desktop-environment-mode)
  (exwm-input-set-key (kbd "<f13> <f12>") #'desktop-environment-screenshot)
  (after! emms
    ; playerctl doesn't play nicely with emms-mpris under exwm (user input blocks because of singlethreadness)
    ; and when controlling spotify directly, Next command just pauses, as automatic play is disabled in the app
    ; so override the controls to point to emms functions
    (advice-add 'desktop-environment-toggle-music :override #'emms-player-pause)
    (advice-add 'desktop-environment-music-next :override
                (lambda () (if emms-random-playlist (emms-random) (emms-next))))
    (advice-add 'desktop-environment-music-previous :override #'emms-previous)))
#+end_src
** wpa-manager
#+begin_src elisp :tangle packages.el :exports none
(package! wpa-manager
  :recipe (:host github :repo "sarg/wpa-manager.el")
  :pin "ec21a9300b5259a8242e6810d2e497b3e4b8d4e0")
#+end_src

#+begin_src elisp
(use-package! wpa-manager
  :init
  (after! evil-collection
    (evil-collection-inhibit-insert-state 'wpa-manager-mode-map)
    (evil-set-initial-state 'wpa-manager-mode-map 'normal)
    (evil-collection-define-key 'normal 'wpa-manager-mode-map
      "s" 'wpa-manager-scan
      "r" 'revert-buffer
      "c" 'wpa-manager-connect
      (kbd "RET") 'wpa-manager-connect)))
#+end_src
** bluetooth
#+begin_src scheme :noweb-ref guix-pkg
"emacs-bluetooth"
#+end_src
#+begin_src elisp :tangle packages.el
(package! bluetooth :built-in t)
#+end_src
#+begin_src elisp
(use-package! bluetooth)
#+end_src
** udisks
#+begin_src elisp :tangle packages.el
(package! debase :recipe (:host codeberg :repo "emacs-weirdware/debase") :pin "0b6fc2af3440d68798e3a85d4c889341aae07936")
(package! discomfort :recipe (:host codeberg :repo "emacs-weirdware/discomfort") :pin "873eea833bbae7196b92bb1102494b8bf5dc5df6")
#+end_src
#+begin_src elisp
(use-package! discomfort
  :config
  (add-to-list 'evil-emacs-state-modes 'discomfort-mode)
  (define-key discomfort-mode-map
              "j" #'next-line
              "k" #'previous-line))
#+end_src
* theme
#+begin_src elisp :tangle packages.el :exports none
(package! circadian :pin "52e336d9bb66cfd6d6dc5b9213ea21796ac873d4")
(package! white-sand-theme :pin "729dd52cc1936250183d6761eed406c4be514a71")
;(package! kaolin-themes)
(package! doom-themes :pin "4c239dbe42232e81c28901000f435746de2a55ab")
#+end_src

#+begin_src elisp
(use-package! white-sand-theme)
(defvar doom-theme-dark 'doom-one)
(setq doom-theme 'white-sand
      doom-font (font-spec :family "Hack" :size 20)
      doom-serif-font (font-spec :family "Hack")
      doom-unicode-font (font-spec :family "Hack"))

;; Change color theme based on day time
(use-package! circadian
  :custom
  (calendar-latitude 52.516667)
  (calendar-longitude 13.388889)
  (circadian-themes
   `((:sunrise . ,doom-theme)
     (:sunset . ,doom-theme-dark)))
  :config
  (circadian-setup))
#+end_src

* gpg
#+begin_src scheme :noweb-ref guix-pkg
"emacs-pinentry"
#+end_src
#+begin_src elisp :tangle packages.el :exports none
(package! pinentry :built-in t)
#+end_src
#+begin_src elisp
(use-package! pinentry
  :config
  (pinentry-start))
#+end_src
* emacs screencast recording
#+begin_src elisp :tangle packages.el
(package! command-log-mode :pin "af600e6b4129c8115f464af576505ea8e789db27")
;(package! camcorder) autoloads fail because of names.el usage. todo: debug
#+end_src

#+begin_src elisp
(use-package! command-log-mode
  :commands command-log-mode)
;; (use-package! camcorder
;;   :commands camcorder-mode
;;   :hook (camcorder-mode-hook . clm/command-log-clear))
#+end_src

#+begin_src scheme :noweb-ref guix-pkg
"recordmydesktop" "ffmpeg"
#+end_src
* miscellaneous
#+begin_src sh :tangle ~/.local/bin/locate :shebang #!/bin/sh :exports none
plocate -d /storage/storage.plocate $@
plocate -d /storage/2tb.plocate $@
plocate -d /storage/500gb.plocate $@
#+end_src

#+begin_src elisp
(setq +modeline-encoding nil
      +modeline-height 20)

;; C-h deletes character backwards
(define-key key-translation-map [?\C-h] [?\C-?])

(setq-default
 ;; russian layout on C-\
 default-input-method "russian-computer")
#+end_src

** Debug icons in modeline, find out their names. :noexport:
#+begin_src elisp :tangle no
(defadvice! +debug-modeline-format-icon (icon-set icon label &optional face &rest args)
  :override +modeline-format-icon
  (propertize (format "X %s" label) 'face face))
#+end_src
* buffers
#+begin_src elisp :tangle packages.el :exports none
(package! bufler :pin "9eba735988c13d5e5e898f44655d9225e444ce02")
#+end_src

#+begin_src elisp
(use-package! bufler
  :config
  (after! exwm
    (exwm-input-set-key (kbd "s-b") #'bufler-switch-buffer))

  (after! evil-collection
    (evil-collection-define-key 'normal 'bufler-list-mode-map
      (kbd "C-k") 'bufler-list-buffer-kill
      "r" 'bufler
      (kbd "RET") 'bufler-list-buffer-switch))

  :custom
  (bufler-groups
   (bufler-defgroups
     (group (mode-match "Telega" (rx bos "telega-chat")))
     (group
      (group-and "X11" (mode-match "exwm-mode" (rx bos "exwm-mode")))
      (group-and "WWW"
       (lambda (b) (string= "qutebrowser" (buffer-local-value 'exwm-class-name b)))))
     (group (auto-project))
     (auto-directory))))
#+end_src
* org mode
- [ ] TODO: Replace linkmarks with bookmark+
#+begin_src elisp :tangle packages.el
(package! linkmarks :recipe (:host github :repo "dustinlacewell/linkmarks") :pin "914bcb9172c5a9c7cab88de31e359de595e85021")
(package! org-modern-indent
    :recipe (:host github :repo "jdtsmith/org-modern-indent")
    :pin "c5a50f302dc1053d5b498e0ea2bc0ee233e8e1b8")
(package! org-modern :built-in t)
#+end_src
#+begin_src scheme :noweb-ref guix-pkg
"emacs-org-modern"
#+end_src

#+begin_src elisp
(setq
 org-directory (expand-file-name "~/Sync/org/")
 org-src-window-setup 'current-window
 org-fold-catch-invisible-edits 'show-and-error)

(use-package! org-contacts
  :custom
  (org-contacts-files (list (expand-file-name "contacts.org" org-directory))))

(use-package! org-modern
  :hook (org-mode org-agenda-finalize))

(use-package! org-modern-indent
  :hook org-mode)

(use-package! linkmarks
  :custom
  (linkmarks-file (expand-file-name "links.org" org-directory))

  :config
  (after! exwm
    (exwm-input-set-key (kbd "s-g") #'linkmarks-select)))

(after! org-download
  (setq org-download-screenshot-method "flameshot gui --raw > %s"))

(load! "org-defuns")
#+end_src
** capture :noexport:
#+begin_src shell :tangle ~/.local/bin/emacs-capture :shebang #!/bin/sh
emacsclient -F '((name . "doom-capture") (height . 10) (width . 80))' "$@"
#+end_src

#+begin_src python :tangle ~/.local/share/qutebrowser/userscripts/orgprotocol :shebang #!/usr/bin/env python3
import os
import subprocess
from urllib.parse import quote

subprocess.call(['emacs-capture',
  'org-protocol://capture?template=t&url={url}&title={title}&body={body}'.format(
    url   = quote(os.environ.get('QUTE_URL', '')),
    title = quote(os.environ.get('QUTE_TITLE', '')),
    body  = quote(os.environ.get('QUTE_SELECTED_TEXT', ''))
  )
])
#+end_src
** agenda
#+begin_src elisp :tangle packages.el :exports none
(package! german-holidays :pin "a8462dffccaf2b665f2032e646b5370e993a386a")
#+end_src

#+begin_src elisp
(use-package! german-holidays
  :custom
  (calendar-holidays holiday-german-BE-holidays))

(setq
 org-agenda-files
 (-map (lambda (el) (expand-file-name el org-directory))
       '("projects.org"
         "tickler.org")))
#+end_src

** roam
#+begin_src elisp
(after! org-roam
  (setq org-roam-db-node-include-function
        (lambda ()
          (not (member "ATTACH" (org-get-tags))))))
#+end_src
** elasticsearch :noexport:
#+begin_src elisp :tangle no
(package! es-mode :pin "e82465fd785688bb58918ea62ca4de06a2a23a1e")
#+end_src

#+begin_src elisp :tangle no
(use-package! es-mode
  :commands (org-babel-execute:es)

  :config
  (appendq!
   +org-babel-mode-alist '((es . elasticsearch))))
#+end_src
* git
#+begin_src elisp :tangle packages.el
(package! magit-todos :disable t) ; too slow
#+end_src

#+begin_src elisp
(after! magit
  (let ((sarg-repos-dir (expand-file-name "~/devel/")))
    (setq magit-repository-directories `((,sarg-repos-dir . 2))
          magit-clone-default-directory `,sarg-repos-dir)))

(after! browse-at-remote
  (setq browse-at-remote-prefer-symbolic nil))
#+end_src
* tramp
#+begin_src elisp
(after! tramp
  (pushnew! tramp-remote-path 'tramp-own-remote-path))
#+end_src
* book reading
#+begin_src elisp :tangle packages.el
(package! calibredb :built-in t)
(package! nov :built-in t)
#+end_src

#+begin_src scheme :noweb-ref guix-pkg
"emacs-calibredb" "sqlite" "emacs-nov-el"
#+end_src

#+begin_src elisp :tangle no
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)

  :custom
  (nov-variable-pitch nil)
  (nov-text-width t))
#+end_src

#+begin_src elisp
(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir (expand-file-name "~/Calibre Library")
        calibredb-db-dir (concat calibredb-root-dir "/metadata.db")
        calibredb-library-alist '(("~/Calibre Library"))
        calibredb-preferred-format 'epub ;; just open it, don't ask

        ;; hide extra columns
        calibredb-date-width 0
        calibredb-format-width 0
        calibredb-tag-width 0
        calibredb-comment-width 0)

  (defalias 'calibredb-open-with-default-tool #'find-file))
#+end_src

* password-store
#+begin_src elisp :tangle packages.el :exports none
(package! password-generator :built-in t)
#+end_src
#+begin_src scheme :noweb-ref guix-pkg
"emacs-password-generator"
#+end_src

#+begin_src elisp
(setq password-cache-expiry (* 60 15))

;; for magithub auth to work create pass entry user^magithub@api.github.com
(after! magit
    (setq magit-process-find-password-functions '(magit-process-password-auth-source)))

(use-package! password-generator
  :after password-store

  :config
  (defadvice! +password-store-edit-locally (entry)
    :override #'password-store-edit
    (interactive (list (password-store--completing-read t)))
    (find-file (password-store--entry-to-file entry)))

  (defadvice! +password-store-generate-strong (entry &optional len)
    :override #'password-store-generate
    (interactive (list (password-store--completing-read)
                       (when current-prefix-arg
                         (abs (prefix-numeric-value current-prefix-arg)))))
    (let ((pass
           (password-generator-strong
            (or len password-store-password-length) t)))
      (password-store-insert entry pass))))
#+end_src

** qutebrowser integration
#+begin_src elisp
(defun +pass/qute (url)
  (auth-source-pass--read-entry
   (completing-read "Pass: "
                    (password-store-list)
                    nil t url)))
#+end_src

#+begin_src bash :tangle ~/.config/qutebrowser/password_fill_rc :exports none
init() { file="not used"; }
choose_entry() { true ; }
no_entries_found() { if [ 0 -eq "${#lines[@]}" ]; then exit 0; fi }

open_entry() {
    local firstline=1
    for line in "${lines[@]}"; do
        if ((firstline)) ; then
            password="$line"
            firstline=0
        else
            if [[ $line =~ $user_pattern ]] ; then
                # remove the matching prefix "user: " from the beginning of the line
                username=${line#${BASH_REMATCH[0]}}
                break
            fi
        fi
    done
}

query_entries() {
    url=$(awk -F'[./]' '{print $(NF-1) "." $(NF)}' <<< "$1")

    set +o errexit
    mapfile -t lines < <(emacsclient -e "(+pass/qute \"$url\")" | jq -r .)
    set -o errexit
}
#+end_src

* music
#+begin_src scheme :noweb-ref guix-pkg
"emacs-emms"
#+end_src
#+begin_src elisp :tangle packages.el
(package! emms :built-in 'prefer)
(package! emms-player-spotify
  :recipe (:host github :repo "sarg/emms-spotify")
  :pin "c953c1bd58067c51e115e3bea3d9bb922ed839ce")
(package! counsel-spotify :pin "2743ad52a9def53534fd505397fbe1ac49e53015")
#+end_src
#+begin_src elisp
(use-package! emms
  ;; (emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
  ;; (emms-browser-covers 'emms-browser-cache-thumbnail)
  :custom
  (emms-player-mpv-update-metadata t)

  :config
  (emms-all)
  (emms-history-load)
  (setq emms-player-list (list emms-player-mpv)
        emms-playlist-buffer-name "*Music*"
        emms-source-file-default-directory (expand-file-name "~/Music/")))

(use-package! emms-player-spotify
  :config
  (emms-player-spotify-adblock t)
  (add-to-list 'emms-player-list emms-player-spotify))

(use-package! counsel-spotify
  :defer t

  :config
  (if (string-empty-p counsel-spotify-client-secret)
      (setq counsel-spotify-client-id (+pass-get-field "Sites/spotify.com" "client-id")
            counsel-spotify-client-secret (+pass-get-field "Sites/spotify.com" "client-secret")))

  (defun emms-player-spotify-expand-album (id)
    (counsel-spotify-with-auth-token (auth-token)
     (counsel-spotify-with-query-results
      (auth-token (concat counsel-spotify-spotify-api-url "/albums/" id "/tracks") results)

      (with-current-emms-playlist
        (goto-char (point-max))
        (ignore (mapc (lambda (el)
            (let ((track (emms-track 'url (uri el))))
              (emms-track-set track 'info-title (name el))
              (emms-track-set track 'info-artist (name (artist el)))
              (emms-track-set track 'info-album (name (album el)))
              (emms-track-set track 'info-playing-time (millis-to-seconds (duration-in-ms el)))
              (emms-playlist-insert-track track)))
          (counsel-spotify-parse-items (list (cons 'tracks results)) 'tracks)))))))

  (cl-defmethod counsel-spotify-do-play ((backend counsel-spotify-linux-backend) (playable counsel-spotify-playable))
    (with-current-emms-playlist
      (goto-char (point-max))
      (cond
       ((counsel-spotify-album-p playable)
        (emms-player-spotify-expand-album
         (nth 2 (string-split (uri playable) ":"))))

       (t
        (let ((track (emms-track 'url (uri playable))))
          (emms-track-set track 'info-artist "Spotify Playlist")
          (emms-track-set track 'info-title
                          (decode-coding-string (string-make-unibyte (name playable)) 'utf-8))
          (emms-playlist-insert-track track)
          (emms-playlist-mode-play-current-track)))))))
#+end_src
* elfeed
#+begin_src elisp
(defun elfeed-open-special ()
  "Open videos directly."
  (interactive)
  (let ((entry (elfeed-search-selected :single)))
    (if (seq-contains-p (elfeed-entry-tags entry) 'youtube)
        (elfeed-search-browse-url)
      (elfeed-search-show-entry entry))))

(defun sarg/elfeed-strip-content (entry)
  (when (seq-contains-p (elfeed-entry-tags entry) 'rmbody)
    (setf (elfeed-entry-content entry) (elfeed-ref ""))
    (elfeed-untag entry 'rmbody)))

(after! elfeed
  (setq elfeed-db-directory "/storage/data/elfeed")
  (add-hook 'elfeed-new-entry-hook #'sarg/elfeed-strip-content)
  (add-hook 'elfeed-show-mode-hook (lambda () (setq-local browse-url-generic-program "qutebrowser-background")))

  (setq elfeed-search-filter "@2-week-ago +unread -youtube"
        elfeed-show-entry-switch (lambda (buf) (display-buffer-below-selected buf nil) (select-window (get-buffer-window buf))))

  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "RET") 'elfeed-open-special))
#+end_src

#+begin_src sh :tangle ~/.local/bin/qutebrowser-background :shebang #!/bin/sh :exports none
qutebrowser --nowindow --target tab-bg-silent $@
#+end_src

* dict
#+begin_src elisp :tangle packages.el
(package! dictcc :pin "30b505759e5a97c2aaa8b0e8ea5e187fdf625c65")
(package! multitran :pin "6244e227bcf57eed391eecb34bae445f9c17e809")
(package! google-translate :pin "e60dd6eeb9cdb931d9d8bfbefc29a48ef9a21bd9")
(package! powerthesaurus :pin "8bcc2a7f7d1751e34291a1983885da3ebb8c3023")
#+end_src
* email
- [ ] TODO: fix mu4e popping up for mailto urls
#+begin_src desktop :tangle ~/.local/share/applications/emacsclient-mail.desktop
[Desktop Entry]
Categories=Network;Email;
Comment=GNU Emacs is an extensible, customizable text editor - and more
Exec=emacs-mail %u
Icon=emacs
Name=Emacs (Mail, Client)
MimeType=x-scheme-handler/mailto;
NoDisplay=true
Terminal=false
Type=Application
Keywords=emacsclient;
Actions=new-window;new-instance;
#+end_src
#+begin_src shell :tangle ~/.local/bin/emacs-mail :shebang #!/bin/sh
emacsclient --eval "(message-mailto \"$1\")"
#+end_src
#+begin_src elisp
(defun sarg/ensure-msmtp-pass-available ()
  (interactive)
  (auth-source-pass-get (concat "Email/" user-mail-address) 'secret))

(after! mu4e
  (setq mu4e-filter-inbox "flag:unread AND NOT flag:trashed AND maildir:/gmail/Inbox"
        mu4e-bookmarks `((,mu4e-filter-inbox "Gmail messages" ?u)
                         ("date:today..now AND NOT flag:trashed AND NOT maildir:/gmail/trash" "Today's messages" 116))

        mu4e-alert-interesting-mail-query mu4e-filter-inbox)

  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . 8bit))
  (advice-add 'sendmail-send-it
              :before #'sarg/ensure-msmtp-pass-available)

  (setq sendmail-program (executable-find "msmtp")
        send-mail-function #'sendmail-send-it
        mu4e-compose-format-flowed t ; visual-line-mode + auto-fill upon sending
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function #'message-send-mail-with-sendmail))

(set-email-account! "sarg"
  '((mu4e-sent-folder   . "/gmail/sent")
    (mu4e-drafts-folder . "/gmail/drafts")
    (mu4e-trash-folder  . "/gmail/trash")
    (mu4e-refile-folder . "/gmail/all")
    (smtpmail-smtp-user . "sarg@sarg.org.ru")
    (user-mail-address  . "sarg@sarg.org.ru"))
  t)
#+end_src

* browsing
#+begin_src elisp :tangle packages.el
(package! webpaste :built-in t)
(package! web-search :pin "a22cbdc663a1895d5a5b69de91e1e3b9eb64b92f")
(package! mpv :built-in t)
#+end_src
#+begin_src scheme :noweb-ref guix-pkg
"emacs-mpv" "emacs-webpaste"
#+END_src
#+begin_src elisp
(defun browse-url-qute-private (url &rest _)
  "Make qutebrowser open URL in private-browsing window."
  (interactive (browse-url-interactive-arg "URL: "))
  (let ((process-environment (browse-url-process-environment)))
    (start-process "qutebrowser-private" nil
           "qutebrowser" "--target" "private-window" url)))

(defun browse-url-mpv (url &rest _)
  (mpv-play-url url))

(setq browse-url-handlers
      '(("youtu\\.?be" . browse-url-mpv)))

(setq-default
 browse-url-browser-function 'browse-url-generic
 browse-url-generic-program "qutebrowser")

(use-package! web-search
  :commands web-search
  :custom
  (web-search-default-provider "DuckDuckGo"))
#+end_src
* shell
#+begin_src elisp :tangle packages.el
(package! eat :built-in t)
(package! detached :built-in t)
#+end_src

#+begin_src scheme :noweb-ref guix-pkg
"emacs-eat" "emacs-detached"
#+end_src

#+begin_src scheme :noweb-ref guix-srv :tangle no :exports none
(simple-service 'eat-bash-integration home-bash-service-type
 (home-bash-extension
  (bashrc (list
           (plain-file "eat"
            "[ -n \"$EAT_SHELL_INTEGRATION_DIR\" ] && source \"$EAT_SHELL_INTEGRATION_DIR/bash\"")))))
#+end_src

#+begin_src elisp
(after! eshell
  (add-hook 'eshell-first-time-mode-hook
            (lambda ()
              (map! :map eshell-mode-map
                    :ni "C-r" #'+eshell/search-history))))

(use-package! eat
  :hook (eshell-load . (eat-eshell-mode eat-eshell-visual-command-mode)))

(use-package! detached
  :init
  (detached-init)
  :bind (;; Replace `async-shell-command' with `detached-shell-command'
         ([remap async-shell-command] . detached-shell-command)
         ;; Replace `compile' with `detached-compile'
         ([remap compile] . detached-compile)
         ([remap recompile] . detached-compile-recompile)
         ;; Replace built in completion of sessions with `consult'
         ([remap detached-open-session] . detached-consult-session))
  :custom ((detached-show-output-on-attach t)
           (detached-terminal-data-command system-type)))
#+end_src

* dired
#+begin_src elisp :tangle packages.el
(package! dired-filter :built-in t)
(package! dired-avfs :built-in t)
(package! dired-du :built-in t)
(package! dired-collapse :pin "1596e516835099b96cb65d1dc372cfbdff6aea96")
(package! dired-git-info
  :recipe (:host github :repo "clemera/dired-git-info")
  :built-in t)
(package! openwith :built-in t)
#+end_src

#+begin_src scheme :noweb-ref guix-pkg
"emacs-dired-hacks" "emacs-dired-du"
"emacs-dired-git-info" "emacs-openwith"
#+end_src

#+begin_src elisp
(use-package! dired-filter
  :hook dired-mode
  :custom
  (dired-filter-stack '((omit) (dot-files))))

(use-package! dired-collapse
  :hook dired-mode)

(use-package! dired-git-info
  :custom
  (dgi-commit-message-format "%cr\t%s"))

(use-package! dired-avfs)
(use-package! dired-du
  :custom
  ;; human readable
  (dired-du-size-format 't))

(add-hook! dired-mode #'dired-hide-details-mode)

(after! async
  (dired-async-mode 1))

(defun openwith-has-association (file)
  (-any? (lambda (oa) (string-match (car oa) file)) openwith-associations))

(use-package! openwith
  :hook (after-init . openwith-mode)
  :custom
  (openwith-associations
   '(("\\.\\(?:pdf\\|epub\\)\\'" "zathura" (file))
     ("\\.\\(?:mkv\\|webm\\|avi\\|mp4\\)\\'" "mpv" (file))))

  :config
  ;; Don't ask if file is too large when it'll be handled by openwith-mode.
  (advice-add 'abort-if-file-too-large :before-until
              (lambda (size op-type filename &rest args)
                (and (boundp 'openwith-mode) openwith-mode
                     (openwith-has-association filename)))))
#+end_src

* bindings
#+begin_src elisp
(map!
 "C-x b" #'bufler-switch-buffer

 (:map dired-mode-map
  :n (kbd "DEL") #'dired-up-directory
  :n "K" #'dired-do-kill-lines)

 (:map image-mode-map
   :n "q" #'kill-current-buffer))
#+end_src
** exwm
#+begin_src elisp :tangle no :results value pp :wrap example elisp :exports both
(-map (lambda (el) (cons (key-description (car el)) (cdr el)))
      exwm-input-global-keys)
#+end_src

#+CAPTION: Just for reference
#+RESULTS:
#+begin_example elisp
(("s-<tab>" . exwm-jump-to-last-exwm)
 ("<f13> 1" lambda nil
  (interactive)
  (exwm-workspace-switch 0))
 ("<f13> 2" lambda nil
  (interactive)
  (exwm-workspace-switch 1))
 ("<f13> 3" lambda nil
  (interactive)
  (exwm-workspace-switch 2))
 ("<f13> 4" lambda nil
  (interactive)
  (exwm-workspace-switch 3))
 ("<f13> 5" lambda nil
  (interactive)
  (exwm-workspace-switch 4))
 ("<f13> 6" lambda nil
  (interactive)
  (exwm-workspace-switch 5))
 ("<f13> 7" lambda nil
  (interactive)
  (exwm-workspace-switch 6))
 ("<f13> 8" lambda nil
  (interactive)
  (exwm-workspace-switch 7))
 ("<f13> 9" lambda nil
  (interactive)
  (exwm-workspace-switch 8))
 ("<f13> r" . app-launcher-run-app)
 ("<f13> h" . evil-window-left)
 ("<f13> j" . evil-window-down)
 ("<f13> k" . evil-window-up)
 ("<f13> l" . evil-window-right)
 ("<f13> e" lambda nil
  (interactive)
  (sarg/run-or-raise "qutebrowser" "qutebrowser")
  (exwm-workspace-switch
   (exwm-workspace-name-to-index "brow")))
 ("s-b" . bufler-switch-buffer)
 ("s-g" . linkmarks-select)
 ("<f13> <f12>" . desktop-environment-screenshot)
 ("<XF86AudioStop>" . desktop-environment-music-stop)
 ("<XF86AudioNext>" . desktop-environment-music-next)
 ("<XF86AudioPrev>" . desktop-environment-music-previous)
 ("<XF86AudioPlay>" . desktop-environment-toggle-music)
 ("<XF86Bluetooth>" . desktop-environment-toggle-bluetooth)
 ("<XF86WLAN>" . desktop-environment-toggle-wifi)
 ("<XF86ScreenSaver>" . desktop-environment-lock-screen)
 ("s-l" . desktop-environment-lock-screen)
 ("<print>" . desktop-environment-screenshot)
 ("S-<print>" . desktop-environment-screenshot-part)
 ("<XF86AudioMicMute>" . desktop-environment-toggle-microphone-mute)
 ("<XF86AudioMute>" . desktop-environment-toggle-mute)
 ("S-<XF86AudioLowerVolume>" . desktop-environment-volume-decrement-slowly)
 ("S-<XF86AudioRaiseVolume>" . desktop-environment-volume-increment-slowly)
 ("<XF86AudioLowerVolume>" . desktop-environment-volume-decrement)
 ("<XF86AudioRaiseVolume>" . desktop-environment-volume-increment)
 ("S-<XF86MonBrightnessDown>" . desktop-environment-brightness-decrement-slowly)
 ("S-<XF86MonBrightnessUp>" . desktop-environment-brightness-increment-slowly)
 ("<XF86MonBrightnessDown>" . desktop-environment-brightness-decrement)
 ("<XF86MonBrightnessUp>" . desktop-environment-brightness-increment))
#+end_example

* archive :noexport:
** emacs-one-frame
#+begin_src sh :tangle no :shebang #!/bin/bash
# https://taingram.org/2017/05/09/using-emacsclient-to-speed-up-editing/
# if no args open new frame
if [ $# -eq 0 ]; then
    emacsclient -c -n
    exit
fi

emacsclient -e "(frames-on-display-list \"$DISPLAY\")" &>/dev/null

if [ $? -eq 0 ]; then
    emacsclient -n "$*"
else
    emacsclient -c -n "$*"
fi
#+end_src
** openscad
#+begin_src elisp :tangle no
(defun openscad-preview ()
  (interactive)
  (select-window (split-window-right))
  (start-process "openscad" nil "openscad" (buffer-file-name)))
#+end_src

** selfcontrol
#+begin_src elisp :tangle no
(defun sarg/ad-selfcontrol-time-restriction (orig-fun &rest args)
  (if (or (= 0 (mod
                (calendar-day-of-week (calendar-current-date))
                6)) ; 0 and 6 - Sunday and Saturday
          (> (nth 2 (decode-time)) 18))
      (apply orig-fun args)
    (message "It's not the time yet!")))

(defun sarg/ad-selfcontrol-otp-confirm (proc &rest args)
  "Asks to enter random string as confirmation before executing PROC."
  (interactive)
  (let* ((pass (format "%06x%06x%06x"
                       (random (expt 16 6))
                       (random (expt 16 6))
                       (random (expt 16 6))))

         (input (read-string (format "Enter %s if you wish to proceed: " pass))))

    (if (string= input pass)
        (apply proc args))))

(after! elfeed
  (advice-add 'elfeed-update :around #'sarg/ad-selfcontrol-otp-confirm)
  (advice-add '=rss :around #'sarg/ad-selfcontrol-otp-confirm)
  (advice-add 'elfeed-update :around #'sarg/selfcontrol-time-restriction))

(after! telega
  (advice-add 'ivy-telega-chat-with :around #'sarg/ad-selfcontrol-otp-confirm))
#+end_src

** fate
#+begin_src elisp :tangle no
(use-package! fate
  :disabled
  :load-path "~/devel/ext/fate"
  :config
  (setq fate:data-file "~/.events/win")

  (defun fate:buffer-string (buffer)
    "Return either path or name of BUFFER."
    (or (buffer-file-name buffer)
        (buffer-name buffer)))

  (defun fate:log-state (state)
    "Write STATE to the database file."
    (write-region state nil fate:data-file 'append :inhibit))

  (defun fate:state-string-base (left right)
    "Represent state using LEFT and RIGHT."
    (format "%s;win;%s;%s\n"
            (format-time-string "%s.%6N")
            (fate:escape left)
            (fate:escape right))))
#+end_src
