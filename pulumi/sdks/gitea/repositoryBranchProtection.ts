// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class RepositoryBranchProtection extends pulumi.CustomResource {
    /**
     * Get an existing RepositoryBranchProtection resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: RepositoryBranchProtectionState, opts?: pulumi.CustomResourceOptions): RepositoryBranchProtection {
        return new RepositoryBranchProtection(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gitea:index/repositoryBranchProtection:RepositoryBranchProtection';

    /**
     * Returns true if the given object is an instance of RepositoryBranchProtection.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is RepositoryBranchProtection {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === RepositoryBranchProtection.__pulumiType;
    }

    /**
     * Only reviews from allowlisted teams will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    public readonly approvalWhitelistTeams!: pulumi.Output<string[] | undefined>;
    /**
     * Only reviews from allowlisted users will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    public readonly approvalWhitelistUsers!: pulumi.Output<string[] | undefined>;
    /**
     * Merging will not be possible when it has official review requests, even if there are enough approvals.
     */
    public readonly blockMergeOnOfficialReviewRequests!: pulumi.Output<boolean | undefined>;
    /**
     * Merging will not be possible when head branch is behind base branch.
     */
    public readonly blockMergeOnOutdatedBranch!: pulumi.Output<boolean | undefined>;
    /**
     * Merging will not be possible when changes are requested by official reviewers, even if there are enough approvals.
     */
    public readonly blockMergeOnRejectedReviews!: pulumi.Output<boolean | undefined>;
    /**
     * Webhook creation timestamp
     */
    public /*out*/ readonly createdAt!: pulumi.Output<string>;
    /**
     * When new commits that change the content of the pull request are pushed to the branch, old approvals will be dismissed.
     */
    public readonly dismissStaleApprovals!: pulumi.Output<boolean | undefined>;
    /**
     * True if a approval whitelist is used.
     */
    public /*out*/ readonly enableApprovalWhitelist!: pulumi.Output<boolean>;
    /**
     * True if a merge whitelist is used.
     */
    public /*out*/ readonly enableMergeWhitelist!: pulumi.Output<boolean>;
    /**
     * Anyone with write access will be allowed to push to this branch (but not force push), add a whitelist users or teams to
     * limit access.
     */
    public readonly enablePush!: pulumi.Output<boolean | undefined>;
    /**
     * True if a push whitelist is used.
     */
    public /*out*/ readonly enablePushWhitelist!: pulumi.Output<boolean>;
    /**
     * Require status checks to pass before merging. When enabled, commits must first be pushed to another branch, then merged
     * or pushed directly to a branch that matches this rule after status checks have passed. If no contexts are matched, the
     * last commit must be successful regardless of context
     */
    public /*out*/ readonly enableStatusCheck!: pulumi.Output<boolean>;
    /**
     * Allow only allowlisted teams to merge pull requests into this branch.
     */
    public readonly mergeWhitelistTeams!: pulumi.Output<string[] | undefined>;
    /**
     * Allow only allowlisted users to merge pull requests into this branch.
     */
    public readonly mergeWhitelistUsers!: pulumi.Output<string[] | undefined>;
    /**
     * Repository name
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Protected file patterns (separated using semicolon ';')
     */
    public readonly protectedFilePatterns!: pulumi.Output<string | undefined>;
    /**
     * Allow deploy keys with write access to push. Requires enable_push to be set to true.
     */
    public readonly pushWhitelistDeployKeys!: pulumi.Output<boolean | undefined>;
    /**
     * Allowlisted teams for pushing. Requires enable_push to be set to true.
     */
    public readonly pushWhitelistTeams!: pulumi.Output<string[] | undefined>;
    /**
     * Allowlisted users for pushing. Requires enable_push to be set to true.
     */
    public readonly pushWhitelistUsers!: pulumi.Output<string[] | undefined>;
    public readonly repositoryBranchProtectionId!: pulumi.Output<string>;
    /**
     * Reject pushes to this branch if they are unsigned or unverifiable.
     */
    public readonly requireSignedCommits!: pulumi.Output<boolean | undefined>;
    /**
     * Allow only to merge pull request with enough positive reviews.
     */
    public readonly requiredApprovals!: pulumi.Output<number | undefined>;
    /**
     * Protected Branch Name Pattern
     */
    public readonly ruleName!: pulumi.Output<string>;
    /**
     * Enter patterns to specify which status checks must pass before branches can be merged into a branch that matches this
     * rule. Each line specifies a pattern. Patterns cannot be empty.
     */
    public readonly statusCheckPatterns!: pulumi.Output<string[] | undefined>;
    /**
     * Unprotected file patterns (separated using semicolon ';')
     */
    public readonly unprotectedFilePatterns!: pulumi.Output<string | undefined>;
    /**
     * Webhook creation timestamp
     */
    public /*out*/ readonly updatedAt!: pulumi.Output<string>;
    /**
     * User name or organization name
     */
    public readonly username!: pulumi.Output<string>;

    /**
     * Create a RepositoryBranchProtection resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: RepositoryBranchProtectionArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: RepositoryBranchProtectionArgs | RepositoryBranchProtectionState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as RepositoryBranchProtectionState | undefined;
            resourceInputs["approvalWhitelistTeams"] = state ? state.approvalWhitelistTeams : undefined;
            resourceInputs["approvalWhitelistUsers"] = state ? state.approvalWhitelistUsers : undefined;
            resourceInputs["blockMergeOnOfficialReviewRequests"] = state ? state.blockMergeOnOfficialReviewRequests : undefined;
            resourceInputs["blockMergeOnOutdatedBranch"] = state ? state.blockMergeOnOutdatedBranch : undefined;
            resourceInputs["blockMergeOnRejectedReviews"] = state ? state.blockMergeOnRejectedReviews : undefined;
            resourceInputs["createdAt"] = state ? state.createdAt : undefined;
            resourceInputs["dismissStaleApprovals"] = state ? state.dismissStaleApprovals : undefined;
            resourceInputs["enableApprovalWhitelist"] = state ? state.enableApprovalWhitelist : undefined;
            resourceInputs["enableMergeWhitelist"] = state ? state.enableMergeWhitelist : undefined;
            resourceInputs["enablePush"] = state ? state.enablePush : undefined;
            resourceInputs["enablePushWhitelist"] = state ? state.enablePushWhitelist : undefined;
            resourceInputs["enableStatusCheck"] = state ? state.enableStatusCheck : undefined;
            resourceInputs["mergeWhitelistTeams"] = state ? state.mergeWhitelistTeams : undefined;
            resourceInputs["mergeWhitelistUsers"] = state ? state.mergeWhitelistUsers : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["protectedFilePatterns"] = state ? state.protectedFilePatterns : undefined;
            resourceInputs["pushWhitelistDeployKeys"] = state ? state.pushWhitelistDeployKeys : undefined;
            resourceInputs["pushWhitelistTeams"] = state ? state.pushWhitelistTeams : undefined;
            resourceInputs["pushWhitelistUsers"] = state ? state.pushWhitelistUsers : undefined;
            resourceInputs["repositoryBranchProtectionId"] = state ? state.repositoryBranchProtectionId : undefined;
            resourceInputs["requireSignedCommits"] = state ? state.requireSignedCommits : undefined;
            resourceInputs["requiredApprovals"] = state ? state.requiredApprovals : undefined;
            resourceInputs["ruleName"] = state ? state.ruleName : undefined;
            resourceInputs["statusCheckPatterns"] = state ? state.statusCheckPatterns : undefined;
            resourceInputs["unprotectedFilePatterns"] = state ? state.unprotectedFilePatterns : undefined;
            resourceInputs["updatedAt"] = state ? state.updatedAt : undefined;
            resourceInputs["username"] = state ? state.username : undefined;
        } else {
            const args = argsOrState as RepositoryBranchProtectionArgs | undefined;
            if ((!args || args.ruleName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'ruleName'");
            }
            if ((!args || args.username === undefined) && !opts.urn) {
                throw new Error("Missing required property 'username'");
            }
            resourceInputs["approvalWhitelistTeams"] = args ? args.approvalWhitelistTeams : undefined;
            resourceInputs["approvalWhitelistUsers"] = args ? args.approvalWhitelistUsers : undefined;
            resourceInputs["blockMergeOnOfficialReviewRequests"] = args ? args.blockMergeOnOfficialReviewRequests : undefined;
            resourceInputs["blockMergeOnOutdatedBranch"] = args ? args.blockMergeOnOutdatedBranch : undefined;
            resourceInputs["blockMergeOnRejectedReviews"] = args ? args.blockMergeOnRejectedReviews : undefined;
            resourceInputs["dismissStaleApprovals"] = args ? args.dismissStaleApprovals : undefined;
            resourceInputs["enablePush"] = args ? args.enablePush : undefined;
            resourceInputs["mergeWhitelistTeams"] = args ? args.mergeWhitelistTeams : undefined;
            resourceInputs["mergeWhitelistUsers"] = args ? args.mergeWhitelistUsers : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["protectedFilePatterns"] = args ? args.protectedFilePatterns : undefined;
            resourceInputs["pushWhitelistDeployKeys"] = args ? args.pushWhitelistDeployKeys : undefined;
            resourceInputs["pushWhitelistTeams"] = args ? args.pushWhitelistTeams : undefined;
            resourceInputs["pushWhitelistUsers"] = args ? args.pushWhitelistUsers : undefined;
            resourceInputs["repositoryBranchProtectionId"] = args ? args.repositoryBranchProtectionId : undefined;
            resourceInputs["requireSignedCommits"] = args ? args.requireSignedCommits : undefined;
            resourceInputs["requiredApprovals"] = args ? args.requiredApprovals : undefined;
            resourceInputs["ruleName"] = args ? args.ruleName : undefined;
            resourceInputs["statusCheckPatterns"] = args ? args.statusCheckPatterns : undefined;
            resourceInputs["unprotectedFilePatterns"] = args ? args.unprotectedFilePatterns : undefined;
            resourceInputs["username"] = args ? args.username : undefined;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["enableApprovalWhitelist"] = undefined /*out*/;
            resourceInputs["enableMergeWhitelist"] = undefined /*out*/;
            resourceInputs["enablePushWhitelist"] = undefined /*out*/;
            resourceInputs["enableStatusCheck"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(RepositoryBranchProtection.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering RepositoryBranchProtection resources.
 */
export interface RepositoryBranchProtectionState {
    /**
     * Only reviews from allowlisted teams will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    approvalWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only reviews from allowlisted users will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    approvalWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Merging will not be possible when it has official review requests, even if there are enough approvals.
     */
    blockMergeOnOfficialReviewRequests?: pulumi.Input<boolean>;
    /**
     * Merging will not be possible when head branch is behind base branch.
     */
    blockMergeOnOutdatedBranch?: pulumi.Input<boolean>;
    /**
     * Merging will not be possible when changes are requested by official reviewers, even if there are enough approvals.
     */
    blockMergeOnRejectedReviews?: pulumi.Input<boolean>;
    /**
     * Webhook creation timestamp
     */
    createdAt?: pulumi.Input<string>;
    /**
     * When new commits that change the content of the pull request are pushed to the branch, old approvals will be dismissed.
     */
    dismissStaleApprovals?: pulumi.Input<boolean>;
    /**
     * True if a approval whitelist is used.
     */
    enableApprovalWhitelist?: pulumi.Input<boolean>;
    /**
     * True if a merge whitelist is used.
     */
    enableMergeWhitelist?: pulumi.Input<boolean>;
    /**
     * Anyone with write access will be allowed to push to this branch (but not force push), add a whitelist users or teams to
     * limit access.
     */
    enablePush?: pulumi.Input<boolean>;
    /**
     * True if a push whitelist is used.
     */
    enablePushWhitelist?: pulumi.Input<boolean>;
    /**
     * Require status checks to pass before merging. When enabled, commits must first be pushed to another branch, then merged
     * or pushed directly to a branch that matches this rule after status checks have passed. If no contexts are matched, the
     * last commit must be successful regardless of context
     */
    enableStatusCheck?: pulumi.Input<boolean>;
    /**
     * Allow only allowlisted teams to merge pull requests into this branch.
     */
    mergeWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allow only allowlisted users to merge pull requests into this branch.
     */
    mergeWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Repository name
     */
    name?: pulumi.Input<string>;
    /**
     * Protected file patterns (separated using semicolon ';')
     */
    protectedFilePatterns?: pulumi.Input<string>;
    /**
     * Allow deploy keys with write access to push. Requires enable_push to be set to true.
     */
    pushWhitelistDeployKeys?: pulumi.Input<boolean>;
    /**
     * Allowlisted teams for pushing. Requires enable_push to be set to true.
     */
    pushWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allowlisted users for pushing. Requires enable_push to be set to true.
     */
    pushWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    repositoryBranchProtectionId?: pulumi.Input<string>;
    /**
     * Reject pushes to this branch if they are unsigned or unverifiable.
     */
    requireSignedCommits?: pulumi.Input<boolean>;
    /**
     * Allow only to merge pull request with enough positive reviews.
     */
    requiredApprovals?: pulumi.Input<number>;
    /**
     * Protected Branch Name Pattern
     */
    ruleName?: pulumi.Input<string>;
    /**
     * Enter patterns to specify which status checks must pass before branches can be merged into a branch that matches this
     * rule. Each line specifies a pattern. Patterns cannot be empty.
     */
    statusCheckPatterns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Unprotected file patterns (separated using semicolon ';')
     */
    unprotectedFilePatterns?: pulumi.Input<string>;
    /**
     * Webhook creation timestamp
     */
    updatedAt?: pulumi.Input<string>;
    /**
     * User name or organization name
     */
    username?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a RepositoryBranchProtection resource.
 */
export interface RepositoryBranchProtectionArgs {
    /**
     * Only reviews from allowlisted teams will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    approvalWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only reviews from allowlisted users will count to the required approvals. Without approval allowlist, reviews from
     * anyone with write access count to the required approvals.
     */
    approvalWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Merging will not be possible when it has official review requests, even if there are enough approvals.
     */
    blockMergeOnOfficialReviewRequests?: pulumi.Input<boolean>;
    /**
     * Merging will not be possible when head branch is behind base branch.
     */
    blockMergeOnOutdatedBranch?: pulumi.Input<boolean>;
    /**
     * Merging will not be possible when changes are requested by official reviewers, even if there are enough approvals.
     */
    blockMergeOnRejectedReviews?: pulumi.Input<boolean>;
    /**
     * When new commits that change the content of the pull request are pushed to the branch, old approvals will be dismissed.
     */
    dismissStaleApprovals?: pulumi.Input<boolean>;
    /**
     * Anyone with write access will be allowed to push to this branch (but not force push), add a whitelist users or teams to
     * limit access.
     */
    enablePush?: pulumi.Input<boolean>;
    /**
     * Allow only allowlisted teams to merge pull requests into this branch.
     */
    mergeWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allow only allowlisted users to merge pull requests into this branch.
     */
    mergeWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Repository name
     */
    name?: pulumi.Input<string>;
    /**
     * Protected file patterns (separated using semicolon ';')
     */
    protectedFilePatterns?: pulumi.Input<string>;
    /**
     * Allow deploy keys with write access to push. Requires enable_push to be set to true.
     */
    pushWhitelistDeployKeys?: pulumi.Input<boolean>;
    /**
     * Allowlisted teams for pushing. Requires enable_push to be set to true.
     */
    pushWhitelistTeams?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allowlisted users for pushing. Requires enable_push to be set to true.
     */
    pushWhitelistUsers?: pulumi.Input<pulumi.Input<string>[]>;
    repositoryBranchProtectionId?: pulumi.Input<string>;
    /**
     * Reject pushes to this branch if they are unsigned or unverifiable.
     */
    requireSignedCommits?: pulumi.Input<boolean>;
    /**
     * Allow only to merge pull request with enough positive reviews.
     */
    requiredApprovals?: pulumi.Input<number>;
    /**
     * Protected Branch Name Pattern
     */
    ruleName: pulumi.Input<string>;
    /**
     * Enter patterns to specify which status checks must pass before branches can be merged into a branch that matches this
     * rule. Each line specifies a pattern. Patterns cannot be empty.
     */
    statusCheckPatterns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Unprotected file patterns (separated using semicolon ';')
     */
    unprotectedFilePatterns?: pulumi.Input<string>;
    /**
     * User name or organization name
     */
    username: pulumi.Input<string>;
}
